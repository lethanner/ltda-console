#include "mixerfader.h"
#include <QStyle>
#include <QStyleOptionSlider>
#include <QPainter>

MixerFader::MixerFader(Qt::Orientation orientation, QWidget *parent)
    : QSlider(orientation, parent) {
    setStyleSheet(R"(
                    QSlider::groove:vertical {
                        border: 1px solid #111;
                        width: 2px;
                        margin: 24px 36px;
                        background-color: #111;
                    }
                    QSlider::handle:vertical {
                        image: url(:/img/knob.png);
                        margin: -24px -36px;
                        height: -1px;
                        background: transparent;
                    })");

    setFixedWidth(40);
    setRange(-97, 10);
    setValue(-97);
}

/* generate level dashes around fader */
void MixerFader::paintEvent(QPaintEvent *event) {
    QSlider::paintEvent(event);

    if (orientation() != Qt::Vertical)
        return;

    QStyleOptionSlider opt;
    initStyleOption(&opt);

    QPainter painter(this);
    painter.setPen(QColor(150, 150, 150));

    QRect grooveRect = style()->subControlRect(QStyle::CC_Slider, &opt, QStyle::SC_SliderGroove, this);

    int step = singleStep();
    int minVal = minimum();
    int maxVal = maximum();

    // yes, it is generated by AI and it's actually works for any window height
    // I'm too lazy to figure out what's really going on here
    // if it works, don't touch it

    if (maxVal == minVal || step <= 0)
        return;

    const int padding = 24;
    const int startY = grooveRect.bottom() - padding;
    const int availableHeight = grooveRect.height() - 2 * padding;
    if (availableHeight <= 0)
        return;

    int x = grooveRect.center().x();

    const int pixelsFor5dB = qRound(5.0 * availableHeight / double(maxVal - minVal));
    const int blockH = std::max(1, pixelsFor5dB);

    for (int v = minVal; v < maxVal; v += step) {
        double frac = double(v - minVal) / double(maxVal - minVal);
        int y = startY - qRound(frac * availableHeight);

        if (v == 5) {
            int h = blockH;
            int h1 = std::max(1, h - 2);
            int h2 = std::max(1, h - 4);
            painter.drawRect(x - 20, y, 6, h1);
            painter.drawRect(x - 20, y + h + 4, 6, h2);
            painter.drawRect(x + 14, y, 6, h1);
            painter.drawRect(x + 14, y + h + 4, 6, h2);
        }

        if ((v < -5 || v > 5)) {
            if (v % 10 == 0) {
                painter.drawLine(x - 20, y, x - 14, y);
                painter.drawLine(x + 20, y, x + 14, y);
            }
            else if (v % 2 == 0) {
                painter.drawLine(x - 20, y, x - 17, y);
                painter.drawLine(x + 20, y, x + 17, y);
            }
        }
    }
}

